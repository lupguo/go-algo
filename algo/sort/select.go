package sort

//Select 选择排序, 每第i趟迭代从未排好序的A[i+1,n-1]列表中，挑选最小值，和已排序区间最后一个元素i进行交换
// 	原地排序, 最好,最坏都是O(N^2)，因为最好情况，也需要从未排序区间，检测每一个元素
//	不是稳定的排序算法：因为针对5,8,5,2,9，第一个5会与2交换，排序前后相同元素的位置变化了
//选择排序和插入排序类似，都是分成已排序和待排序两个区间，选择排序和插入排序的区别:
//	- 选择排序，从剩余待排序区间中的所有元素中，选择一个最小或最大的元素，放入已排序区间; （类似扑克牌挑最小或最大牌，依次排序）
//	- 插入排序，从剩余待排序区间中选择下一个排序元素，依次和已排序区间最后一个元素依次往前匹配，直至放入合适位置；（类似扑克牌摸牌，摸到一张从右到左和已排序区间的牌进行比较）
func Select(A []int, n int) (sortedList []int)  {
	for i:=0; i<n; i++ {
		min := i	// 定义未排序区间的最小值
		for j:=i+1; j<n; j++ {
			if A[min] > A[j] { // 从未排好序列表中，找到更小的则标记
				min = j
			}
		}
		A[i], A[min] = A[min], A[i]
	}
	return A
}
