## 排序算法

### 排序算法分类
- 按计算复杂性分为：最差、最好、平均复杂性，典型好的算法为`O(nlog(n))`，并行排序`O(log^2(n))`，
较差的排序算法复杂度为`O(n^2)`，理想排序复杂度为`O(n)`，不过这是不可能的，最佳并行排序是`O(log n)`
- 计算复杂性，即时间和空间复杂性
- 内存使用情况划分，依据是否需要申请额外内存资源，即是否原地排序算法
- 递归，是否存在递归或非递归算法，或者两者都有（比如归并排序）
- 排序的稳定性，即排序前后，相同元素相对位置没有发生变化
- 是否需要比较排序，与之相对的是无需比较排序，比如`桶排序`、`基数排序`、`计数排序`
- 通用排序方式：插入、交换、选择、归并
    - 交换排序包括`冒泡排序`和`快速排序`
    - 选择排序包括`堆排序`(选择问题）
- 算法是否支持并行：主要讨论串行排序算法
- 算法适应性：算法对输入数据的排序是否有关联性

### 算法稳定性说明
对某些类型的数据进行排序时，在确定排序顺序时，不仅需要考虑到他们的数字内容排序，还需要考虑他们的内容属性。

比如扑克牌除了点数还有花色分类、订单按金额和时间排序；

### 算法比较
主要考虑平均以及最差情况(大O)、内存使用、稳定性，以下主要考虑`比较排序算法`，另外还有`非比较排序算法`不在考虑

#### 比较排序算法，复杂度不会优于nlog(n)
参考： [算法比较](https://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms)

#### 热门的比较排序算法包括
`插入排序`广泛用于小型数据集，而对于大型数据集，则主要是`堆排序`，`归并排序`或`快速排序`。

高效实现通常使用混合算法，比如Golang中的`快速排序`就是在少量元素使用`插入排序`，大量元素使用`快速排序`算法。

这些算法的开销在较小的数据上变得显着，因此通常使用混合算法:

- 一旦数据足够小，通常切换到插入排序。
- 其次，算法通常在已经排序的数据或几乎排序的数据上表现不佳 - 这些在现实世界数据中很常见，并且可以通过适当的算法在O（n）时间内进行排序。
- 最后，排序算法也可能是不稳定的，稳定性通常是一种理想的性质。

因此，通常采用更复杂的算法，例如`Timsort`（基于归并排序）或`introsort`（基于快速排序，回退到堆排序）。

- 有效排序：`O(nlogn)`
    - 快速排序：分治思想，最差复杂度为`O(n^2)`，与`pivot`选择子相关联，最差情况即每次选择子都为最大或最小元素；
    - 堆排序: 堆是一种特殊类型的二叉树(底层利用数组存放元素)，一旦数据列表成为堆，根节点就保证是最大（或最小）的元素。
    - 归并排序：也是分治思想，将大问题先分解成两个相同区间的小问题，然后针对两个有序列表递进行Merge归并操作
- 分布排序：分布排序是指任何排序算法，其中数据从其输入分配到多个CPU处理，然后收集并放置在输出上。
    - 桶排序
    - 计数排序
- 外排序：数据太大而无法放入单个计算机的内存
- 简单排序: 对小数据集开销低，对大数据无效，`O(n^2)`
    - 插入排序: 
    - 选择排序: 
    - 冒泡排序
    - 希尔排序：插入排序的变体