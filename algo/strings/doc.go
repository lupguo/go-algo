package strings

// 模式匹配:
//		1. 单模式匹配: 单串匹配单串(RK、BF, BM、KMP)
//		2. 多模式匹配: 一个串中找多个串(Trie, AC自动机)
// 主串和模式串:
// 		字符串A中找字符串B，A为主串，B为模式串，以下假定主串长度为n，模式串长度为m，方便讨论算法复杂度
// BF:
//		BruteForce，暴力/朴素匹配算法，在主串中，从前往后依次提前长度为模式串长度的临时串，和模式串按字符依次比较
//		复杂度: O(n*m)，由O(m*(n-m+1))而来，即需要遍历(n-m+1)次，每次需要对比模式串长度m个字符
//		优点: KISS原则，小量数据足够简单，够用
// RK:
//		Rabin-Karp，两人名字合并而成，在BF基础上利用Hash函数改进算法
//		计算每个临时串的Hash值，与模式串的Hash对比，不一致跳过，一致则还需比较临时串和模式串(防止Hash冲突问题)
//		Hash算法的设计技巧Tips:
//			1. Hash函数考虑基于字符设定，字符集K，指定K进制，比如字符集为a~z，则k=26，然后按进制比较
//			2. 注意提前将对应算数值(求幂)的结果存储在一个数组中，通过下标指定幂的次数，可以达到空间换时间的效果
//			3. Hash函数考虑基于字符设定，求字符编码求和(0~25)，存在冲突
//		复杂度: O(n)，由O(n-m+1)而来，因为只需要遍历一次字符串即可(无需模式串的字符匹配了)，但当Hash大量冲突，那时间复杂度降低到O(n*m)
//		优点: 比BF效率高，但依赖于Hash函数设计
// BM:
//		Boyer-Moore，由Boyer和Moore设计于1977年，不同于朴素模式（brute-force search）的逐个字符对比，算法充分使用预处理P(对主串预处理)
//			的信息来尽可能跳过更多的字符，而不用向BF和RK算法一样，主串一位一位的往后移动对比，即对于每一次失败的匹配尝试，算法都能够使用这些信息来
//			排除尽可能多的无法匹配的位置。 在实际的软件开发中，特别是一些文本编辑器中，应用比较多。
//		坏字符规则：
//			后移位数 = 坏字符的位置 - 搜索词中的上一次出现位置
//			1. 模式串按从后往前依次与主串字符比对，不匹配的情况，记为坏字符(字符在主串当中)；针对坏字符，算法识别是否在模式串中:
//				a) 若坏字符不在模式串中，则可以将主串比较位置直接后移模式串长度(m)；
//				b) 若坏字符在模式串中，则将模式中从后往前找到的第一个坏字符的位置，与主串中的坏字符对其；
//			2. 利用坏字符规则，最好情况可以是O(n/m)，即每次找到坏字符都不在模式串中，则后移m位
//		好后缀规则
//			后移位数 = 好后缀的位置 - 搜索词中的上一次出现位置
//			1. 模式串按从后往前依次与主串字符比对，若存在好后缀匹配情况，记为好后缀{U}；我们需要从模式串中从后往前找)往前找
//				a) 若好后缀{U}在模式串中，则与主串的好后缀对其，然后继续后续流程
//				b) 若好后缀{U}不在模式串中，则需要与主串好后缀{U}部分对其，然后继续主串后续流程
//		移动字符规则，实际移动为通过这两条规则计算出的最大移动个数
//		参考:
//			1. https://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html
//			2. https://time.geekbang.org/column/article/71525
// KMP:
//
//

