## 排序算法

### 排序算法分类
- 按计算复杂性分为：最差、最好、平均复杂性，典型好的算法为`O(nlog(n))`，并行排序`O(log^2(n))`，
较差的排序算法复杂度为`O(n^2)`，理想排序复杂度为`O(n)`，不过这是不可能的，最佳并行排序是`O(log n)`
- 计算复杂性
- 内存使用情况划分，依据是否需要申请额外内存资源
- 递归，是否递归或非递归算法，或者两者都有（比如归并排序）
- 排序的稳定性
- 是否需要比较排序：
- 通用排序方式：插入、交换、选择、归并，交换排序包括`冒泡排序`和`快速排序`，选择排序包括`堆排序`(选择问题）
- 算法是否支持并行：主要讨论串行排序算法
- 算法适应性：算法对输入数据的排序是否有关联性

### 算法稳定性说明
对某些类型的数据进行排序时，在确定排序顺序时，不仅需要考虑到他们的数字内容排序，还需要考虑他们的内容分类属性，比如扑克牌除了点数还有花色分类

### 算法比较
主要考虑平均以及最差情况(大O)、内存使用、稳定性、使用的排序方式（选择、插入、交互、归并）
以下主要考虑`比较排序算法`，另外还有`非比较排序算法`不在考虑

#### 比较排序算法，复杂度不会优于nlog(n)
参考： [算法比较](https://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms)

#### 热门的比较排序算法包括
`插入排序`广泛用于小型数据集，而对于大型数据集，则使用渐近有效的排序，主要是`堆排序`，`归并排序`或`快速排序`，高效实现通常使用混合算法，比如Golang
中的快速排序就是在少量元素使用插入排序，大量元素使用快速排序算法。

这些算法的开销在较小的数据上变得显着，因此通常使用混合算法，一旦数据足够小，通常切换到插入排序。
其次，算法通常在已经排序的数据或几乎排序的数据上表现不佳 - 这些在现实世界数据中很常见，并且可以通过适当的算法在O（n）时间内进行排序。
最后，它们也可能是不稳定的，稳定性通常是一种理想的性质。

因此，通常采用更复杂的算法，例如`Timsort`（基于归并排序）或`introsort`（基于快速排序，回退到堆排序）。

- 有效排序: `O(nlogn)`
    - 快速排序：分治思想，最差复杂度为`O(n^2)`，与`pivot`选择子相关联
    - 堆排序: 堆，一种特殊类型的二叉树，一旦数据列表成为堆，根节点就保证是最大（或最小）的元素。
    - 归并排序
- 分布排序: 分布排序是指任何排序算法，其中数据从其输入分配到多个CPU处理，然后收集并放置在输出上。
    - 桶排序
    - 计数排序
    - 外排序：数据太大而无法放入单个计算机的内存
- 简单排序: 对小数据集开销低，对大数据无效，`O(n^2)`
    - 插入排序: 
    - 选择排序: 
    - 冒泡排序
    - 希尔排序：插入排序的变体

